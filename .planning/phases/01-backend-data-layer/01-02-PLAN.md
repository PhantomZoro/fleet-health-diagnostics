---
phase: 01-backend-data-layer
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - backend/src/parser/log-parser.ts
  - backend/data/seed.log
  - backend/src/seed/seed-runner.ts
  - backend/src/routes/health.router.ts
  - backend/src/index.ts
autonomous: true
requirements:
  - DATA-01
  - DATA-02

must_haves:
  truths:
    - "Log parser correctly extracts timestamp, vehicleId, level, code, and message from structured log lines"
    - "Malformed log lines are skipped with a warning, not crash the parser"
    - "Seed file contains ~500 events across 15-20 vehicles with real OBD-II codes"
    - "Database is populated with ~500 events on first startup"
    - "Server restart does not duplicate events (count guard)"
    - "GET /health returns status ok with event count"
  artifacts:
    - path: "backend/src/parser/log-parser.ts"
      provides: "Regex-based log file parser"
      exports: ["LogParser", "parseLogLine"]
      min_lines: 30
    - path: "backend/data/seed.log"
      provides: "Realistic seed data file"
      min_lines: 450
    - path: "backend/src/seed/seed-runner.ts"
      provides: "Database seeder with duplicate protection"
      exports: ["seedDatabase"]
      min_lines: 20
    - path: "backend/src/routes/health.router.ts"
      provides: "Health check endpoint"
      exports: ["healthRouter"]
    - path: "backend/src/index.ts"
      provides: "Updated entry point with DataSource init, seeder, and health route"
  key_links:
    - from: "backend/src/parser/log-parser.ts"
      to: "backend/src/types/index.ts"
      via: "imports ParsedLogEntry type"
      pattern: "ParsedLogEntry"
    - from: "backend/src/seed/seed-runner.ts"
      to: "backend/src/parser/log-parser.ts"
      via: "uses parser to read seed.log"
      pattern: "LogParser|parseLogFile"
    - from: "backend/src/seed/seed-runner.ts"
      to: "backend/src/config/database.ts"
      via: "gets DiagnosticEvent repository from AppDataSource"
      pattern: "AppDataSource\\.getRepository"
    - from: "backend/src/index.ts"
      to: "backend/src/seed/seed-runner.ts"
      via: "calls seeder after DataSource.initialize()"
      pattern: "seedDatabase"
    - from: "backend/src/index.ts"
      to: "backend/src/routes/health.router.ts"
      via: "mounts health router"
      pattern: "healthRouter"
---

<objective>
Build the log parser, generate realistic seed data, create the seed runner with duplicate protection, and add the health endpoint. Wire everything into the Express startup sequence.

Purpose: Complete the data layer so that the database is populated with realistic diagnostic events on first startup, validated by the /health endpoint. This is the deliverable for Phase 1.
Output: Server starts, parses seed.log, inserts ~500 events, serves GET /health with event count. Restarts don't duplicate data.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
@.planning/phases/01-backend-data-layer/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create log parser and seed data file</name>
  <files>
    backend/src/parser/log-parser.ts
    backend/data/seed.log
  </files>
  <action>
1. **`backend/src/parser/log-parser.ts`** — Regex-based parser:

   Define the log format: `[ISO_TIMESTAMP] [VEHICLE_ID:VH-XXXX] [LEVEL] [CODE:XXXXX] message text here`

   Implementation:
   - Export a `parseLogLine(line: string): ParsedLogEntry | null` function
     - Use a single regex: `/^\[(.+?)\] \[VEHICLE_ID:(VH-\d{4})\] \[(ERROR|WARN|INFO)\] \[CODE:([A-Z]\d{4})\] (.+)$/`
     - Return `null` for non-matching lines (comments, blank lines, malformed)
   - Export a `parseLogFile(content: string): ParsedLogEntry[]` function
     - Split by newline, parse each line, filter nulls
     - Log `console.warn('Skipping malformed line N: ...')` for non-empty lines that fail to parse
   - Import `ParsedLogEntry` from `../types/index.js`
   - Do NOT use `any` type anywhere

2. **`backend/data/seed.log`** — Generate ~500 realistic log events:

   Vehicle IDs: VH-1001 through VH-1020 (20 vehicles)

   OBD-II codes with realistic messages:
   - `P0300` — "Random/multiple cylinder misfire detected"
   - `P0171` — "System too lean (Bank 1)"
   - `P0420` — "Catalyst system efficiency below threshold (Bank 1)"
   - `P0128` — "Coolant thermostat temperature below regulating"
   - `P0442` — "Evaporative emission control system leak detected (small leak)"
   - `U0100` — "Lost communication with ECM/PCM"
   - `U0401` — "Invalid data received from ECM/PCM"
   - `B1234` — "Interior ambient temperature sensor circuit malfunction"
   - `B1600` — "Airbag system warning lamp circuit malfunction"
   - `C0035` — "Left front wheel speed sensor circuit malfunction"
   - `C0050` — "Right rear wheel speed sensor circuit malfunction"

   BMW-relevant INFO messages (for INFO level, use operational status codes):
   - `P0000` — "Vehicle systems nominal — all checks passed"
   - `B0000` — "Comfort module self-test completed successfully"
   - `C0000` — "Chassis stability control system operational"
   - `U0000` — "Network communication bus check passed"

   Distribution: ~15% ERROR (~75 events), ~30% WARN (~150 events), ~55% INFO (~275 events)

   Time span: 7 days ending at 2026-02-20T23:59:00.000Z. Space events roughly evenly across the 7 days. Use ISO 8601 format with timezone: `2026-02-14T08:23:15.000Z`

   Format each line exactly as:
   ```
   [2026-02-14T08:23:15.000Z] [VEHICLE_ID:VH-1001] [ERROR] [CODE:P0300] Random/multiple cylinder misfire detected
   ```

   Ensure:
   - Some vehicles have 3+ ERRORs (they will be "critical vehicles" in Phase 2)
   - At least 3-4 vehicles should have 3+ errors to test critical vehicle detection
   - Each vehicle has a mix of levels (not all ERROR or all INFO)
   - Events are NOT sorted by timestamp (realistic — logs arrive out of order)

   IMPORTANT: Actually generate all ~500 lines. Do NOT use placeholders or "..." truncation. Each line must be a valid, parseable log entry. Use a script to generate if helpful, but the final seed.log must contain real data.
  </action>
  <verify>
```bash
cd backend
# Count total lines (should be ~500)
wc -l data/seed.log

# Count by level
grep -c '\[ERROR\]' data/seed.log
grep -c '\[WARN\]' data/seed.log
grep -c '\[INFO\]' data/seed.log

# Count unique vehicles
grep -oP 'VEHICLE_ID:VH-\d+' data/seed.log | sort -u | wc -l

# Test parser compiles
npx tsx -e "import { parseLogFile } from './src/parser/log-parser.js'; import { readFileSync } from 'fs'; const entries = parseLogFile(readFileSync('data/seed.log', 'utf-8')); console.log('Parsed:', entries.length, 'entries'); console.log('Sample:', entries[0]);"
```
  </verify>
  <done>
- Log parser correctly parses the defined format into ParsedLogEntry objects
- Malformed lines return null (not throw)
- seed.log has ~500 lines with 15-20 vehicles, real OBD-II codes, 3 severity levels
- Distribution is roughly 15% ERROR / 30% WARN / 55% INFO
- At least 3-4 vehicles have 3+ ERRORs
- Parser successfully parses all seed.log lines with 0 malformed warnings
  </done>
</task>

<task type="auto">
  <name>Task 2: Create seed runner, health endpoint, and wire startup sequence</name>
  <files>
    backend/src/seed/seed-runner.ts
    backend/src/routes/health.router.ts
    backend/src/index.ts
  </files>
  <action>
1. **`backend/src/seed/seed-runner.ts`** — Database seeder:
   - Export `async function seedDatabase(): Promise<void>`
   - Get DiagnosticEvent repository from AppDataSource
   - **Count guard**: `const count = await repo.count()` — if count > 0, log "Database already seeded (N events)" and return early
   - Read `data/seed.log` using `fs.readFileSync` with path resolved relative to process.cwd() (which will be the backend/ directory)
   - Parse using `parseLogFile()`
   - Map ParsedLogEntry[] to DiagnosticEvent[] (create entity instances or plain objects with matching field names)
   - **Bulk insert in chunks**: Use `repo.save(chunk)` with chunks of 100 to avoid SQLite max variable limits
   - Log "Seeded N diagnostic events"
   - Import from `../parser/log-parser.js`, `../config/database.js`, `../entities/diagnostic-event.entity.js`

2. **`backend/src/routes/health.router.ts`** — Health check:
   - Export a `healthRouter` (Express Router)
   - `GET /health` endpoint:
     - Get DiagnosticEvent repository count
     - Return `{ status: "ok", events: count }`
   - Use proper TypeScript types for req/res (import from express)

3. **Update `backend/src/index.ts`** — Wire the startup sequence:
   - Keep existing imports (reflect-metadata, express, cors)
   - Add imports: AppDataSource, seedDatabase, healthRouter
   - Change startup to async sequence:
     ```
     async function bootstrap() {
       await AppDataSource.initialize();
       console.log('Database connected');

       await seedDatabase();

       const app = express();
       app.use(cors());
       app.use(express.json());

       app.use(healthRouter);

       const PORT = process.env.PORT || 3000;
       app.listen(PORT, () => {
         console.log(`Server running on port ${PORT}`);
       });
     }

     bootstrap().catch(console.error);
     ```
   - Database initializes FIRST, then seeds, then starts Express
   - No need for asyncHandler wrapper (Express 5 handles async errors natively per CLAUDE.md)
  </action>
  <verify>
```bash
cd backend

# Clean any existing DB
rm -f data/fleet.db

# Start server, wait for it to be ready
npx tsx src/index.ts &
SERVER_PID=$!
sleep 3

# Check health endpoint
curl -s http://localhost:3000/health | python3 -c "import sys, json; d=json.load(sys.stdin); assert d['status']=='ok'; assert d['events']>=450; print('Health OK, events:', d['events'])"

# Restart to verify no duplication
kill $SERVER_PID
sleep 1
npx tsx src/index.ts &
SERVER_PID=$!
sleep 3

# Check count is same (not doubled)
EVENTS_AFTER=$(curl -s http://localhost:3000/health | python3 -c "import sys, json; print(json.load(sys.stdin)['events'])")
echo "Events after restart: $EVENTS_AFTER (should be same as before)"

kill $SERVER_PID
```
  </verify>
  <done>
- seedDatabase() inserts ~500 events on first run
- Count guard prevents duplicate insertion on restart
- GET /health returns { status: "ok", events: N } where N ~ 500
- Server startup sequence: DataSource init -> seed -> Express listen
- All TypeScript strict mode — no `any` types
- Restart produces identical event count (no duplication)
  </done>
</task>

</tasks>

<verification>
**Phase 1 complete verification (all four success criteria from ROADMAP):**

1. `GET /health` returns `{ status: "ok", events: N }` where N ~ 500
2. SQLite file exists at `backend/data/fleet.db` with correct fields (timestamp, vehicleId, level, code, message)
3. Events span 15-20 vehicles, real OBD-II codes, all three severity levels (ERROR, WARN, INFO)
4. Server restart does not duplicate events — count remains the same

**Additional checks:**
- `npx tsc --noEmit` in backend/ passes with no errors
- No `any` types in any TypeScript file
- All imports use `.js` extension (NodeNext module resolution)
</verification>

<success_criteria>
- Log parser handles the defined format and skips malformed lines
- Seed file contains ~500 realistic diagnostic events
- Events distributed ~15% ERROR / ~30% WARN / ~55% INFO across 15-20 vehicles
- At least 3-4 vehicles have 3+ ERRORs (critical vehicles for Phase 2)
- Database seeded on first startup, no duplicates on restart
- GET /health returns event count confirming successful seed
- TypeScript compiles under strict mode with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-data-layer/01-02-SUMMARY.md`
</output>
