---
phase: 01-backend-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .gitignore
  - backend/package.json
  - backend/tsconfig.json
  - backend/src/index.ts
  - backend/src/config/database.ts
  - backend/src/entities/diagnostic-event.entity.ts
  - backend/src/types/index.ts
  - frontend/.gitkeep
autonomous: true
requirements:
  - DATA-03

must_haves:
  truths:
    - "Express server starts and listens on port 3000"
    - "TypeORM DataSource initializes with SQLite backend"
    - "DiagnosticEvent entity defines all required fields with proper types and indexes"
    - "npm run dev starts the server with tsx watch"
  artifacts:
    - path: "backend/package.json"
      provides: "Dependencies and scripts"
      contains: "express"
    - path: "backend/tsconfig.json"
      provides: "TypeScript strict configuration"
      contains: "strict"
    - path: "backend/src/index.ts"
      provides: "Express app entry point"
      min_lines: 15
    - path: "backend/src/config/database.ts"
      provides: "TypeORM DataSource with SQLite"
      exports: ["AppDataSource"]
    - path: "backend/src/entities/diagnostic-event.entity.ts"
      provides: "DiagnosticEvent entity with indexed columns"
      exports: ["DiagnosticEvent"]
    - path: "backend/src/types/index.ts"
      provides: "Shared TypeScript interfaces"
  key_links:
    - from: "backend/src/index.ts"
      to: "backend/src/config/database.ts"
      via: "imports AppDataSource and initializes before listen"
      pattern: "AppDataSource\\.initialize"
    - from: "backend/src/config/database.ts"
      to: "backend/src/entities/diagnostic-event.entity.ts"
      via: "entities array in DataSource config"
      pattern: "DiagnosticEvent"
---

<objective>
Scaffold the backend monorepo structure, create the Express 5 server, configure TypeORM with SQLite, and define the DiagnosticEvent entity with proper indexes.

Purpose: Establish the project foundation — working server + database connection + entity — so that subsequent plans can build parser, seeder, and endpoints on top.
Output: Running Express server with TypeORM connected to SQLite, DiagnosticEvent entity ready for data insertion.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Scaffold backend project with Express 5 and TypeScript</name>
  <files>
    backend/package.json
    backend/tsconfig.json
    backend/src/index.ts
    backend/src/types/index.ts
    frontend/.gitkeep
  </files>
  <action>
Create the monorepo directory structure:

1. **`backend/package.json`** with:
   - `name`: "fleet-health-backend"
   - `type`: "module"
   - `scripts`:
     - `"dev": "tsx watch src/index.ts"`
     - `"build": "tsc"`
     - `"start": "node dist/index.js"`
   - Dependencies: `express@^5.0.0`, `cors@^2.8.5`, `better-sqlite3@^11.0.0`, `typeorm@^0.3.20`, `reflect-metadata@^0.2.2`
   - DevDependencies: `typescript@^5.5.0`, `tsx@^4.19.0`, `@types/express@^5.0.0`, `@types/cors@^2.8.17`, `@types/better-sqlite3@^7.6.11`

2. **`backend/tsconfig.json`** with:
   - `"strict": true`
   - `"target": "ES2022"`
   - `"module": "NodeNext"`, `"moduleResolution": "NodeNext"`
   - `"outDir": "./dist"`, `"rootDir": "./src"`
   - `"experimentalDecorators": true`, `"emitDecoratorMetadata": true` (required by TypeORM)
   - `"esModuleInterop": true`, `"skipLibCheck": true`
   - `"resolveJsonModule": true`
   - Include: `["src/**/*"]`

3. **`backend/src/index.ts`** — Express app entry point:
   - Import `reflect-metadata` at the very top (required by TypeORM decorators)
   - Import express, cors
   - Create Express app with `express.json()` and `cors()` middleware
   - Export the app (for testing later)
   - Listen on `process.env.PORT || 3000`
   - Log "Server running on port {PORT}" on startup
   - NOTE: Do NOT initialize DataSource yet — that will be wired in Plan 02 after the seeder exists

4. **`backend/src/types/index.ts`** — Shared type definitions:
   - Export `DiagnosticLevel` as `'ERROR' | 'WARN' | 'INFO'`
   - Export `ParsedLogEntry` interface: `{ timestamp: Date; vehicleId: string; level: DiagnosticLevel; code: string; message: string }`

5. **`frontend/.gitkeep`** — placeholder for frontend directory

6. Create empty directories (via placing a `.gitkeep` or by the files above): `backend/data/`, `backend/src/config/`, `backend/src/entities/`, `backend/src/middleware/`, `backend/src/routes/`, `backend/src/services/`, `backend/src/parser/`, `backend/src/seed/`

7. Update root `.gitignore` to include: `node_modules/`, `dist/`, `*.db`, `.env`, `backend/data/*.db`
  </action>
  <verify>
Run from the backend directory:
```
cd backend && npm install && npx tsx src/index.ts &
sleep 2
curl http://localhost:3000 2>/dev/null
# Should get a response (404 is fine — no routes yet)
kill %1
```
Confirm: `npm install` succeeds with no errors, `tsx` starts the server, port 3000 is listening.
  </verify>
  <done>
- backend/package.json has all dependencies, scripts work
- backend/tsconfig.json is strict mode with decorator support
- Express server starts on port 3000 via `tsx watch`
- Directory structure matches monorepo layout from ROADMAP
- TypeScript compiles with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DiagnosticEvent entity and TypeORM DataSource config</name>
  <files>
    backend/src/entities/diagnostic-event.entity.ts
    backend/src/config/database.ts
  </files>
  <action>
1. **`backend/src/entities/diagnostic-event.entity.ts`** — TypeORM entity:
   ```typescript
   import { Entity, PrimaryGeneratedColumn, Column, Index } from 'typeorm';

   @Entity('diagnostic_events')
   export class DiagnosticEvent {
     @PrimaryGeneratedColumn()
     id!: number;

     @Index()
     @Column({ type: 'datetime' })
     timestamp!: Date;

     @Index()
     @Column({ type: 'varchar', length: 10 })
     vehicleId!: string;

     @Index()
     @Column({ type: 'varchar', length: 5 })
     level!: string;  // 'ERROR' | 'WARN' | 'INFO'

     @Index()
     @Column({ type: 'varchar', length: 10 })
     code!: string;

     @Column({ type: 'text' })
     message!: string;
   }
   ```
   - Use `!` non-null assertion on all columns (TypeORM initializes them)
   - Do NOT use `any` — use `string` for level column (DB stores it as varchar, validation happens at service layer)
   - All four filterable fields (timestamp, vehicleId, level, code) have `@Index()` for query performance

2. **`backend/src/config/database.ts`** — TypeORM DataSource:
   ```typescript
   import { DataSource } from 'typeorm';
   import { DiagnosticEvent } from '../entities/diagnostic-event.entity.js';

   export const AppDataSource = new DataSource({
     type: 'better-sqlite3',
     database: 'data/fleet.db',
     synchronize: true,  // Dev only — rebuilds tables on schema change
     logging: false,
     entities: [DiagnosticEvent],
     subscribers: [],
     migrations: [],
   });
   ```
   - Use `better-sqlite3` driver type (NOT `sqlite`)
   - Database path is relative to where the process runs (backend/ directory)
   - `synchronize: true` is intentional for dev — per CLAUDE.md this is for dev seeding only
   - Include `.js` extension in entity import (NodeNext module resolution requires it)
  </action>
  <verify>
Add a temporary test in index.ts to verify DataSource initializes:
```typescript
// Temporary verification — will be replaced in Plan 02 with proper startup sequence
import { AppDataSource } from './config/database.js';
AppDataSource.initialize().then(() => {
  console.log('Database initialized');
  console.log('Entity metadata:', AppDataSource.entityMetadatas.map(e => e.name));
}).catch(console.error);
```
Run `cd backend && npx tsx src/index.ts` — should print "Database initialized" and entity metadata showing DiagnosticEvent.
Check that `backend/data/fleet.db` is created.
Remove the temporary test code after verification.
  </verify>
  <done>
- DiagnosticEvent entity has id (PK), timestamp, vehicleId, level, code, message — all with correct column types
- Indexes exist on timestamp, vehicleId, level, code
- AppDataSource connects to SQLite via better-sqlite3
- DataSource initializes without errors
- fleet.db file is created in backend/data/
  </done>
</task>

</tasks>

<verification>
1. Run `cd backend && npm install` — succeeds with zero errors
2. Run `cd backend && npx tsc --noEmit` — TypeScript compiles with no errors
3. Run `cd backend && npx tsx src/index.ts` — server starts, prints port message
4. DataSource initializes and creates fleet.db with diagnostic_events table
5. Verify table schema: `sqlite3 backend/data/fleet.db ".schema diagnostic_events"` — shows all columns and indexes
</verification>

<success_criteria>
- Express 5 server starts on port 3000
- TypeScript strict mode compiles without errors
- TypeORM DataSource initializes with SQLite
- DiagnosticEvent entity creates table with all 6 fields (id, timestamp, vehicleId, level, code, message)
- Four indexes exist (timestamp, vehicleId, level, code)
- `npm run dev` works with tsx watch
- Directory structure matches ROADMAP specification
</success_criteria>

<output>
After completion, create `.planning/phases/01-backend-data-layer/01-01-SUMMARY.md`
</output>
