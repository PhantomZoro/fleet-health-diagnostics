---
phase: 03-frontend-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - frontend/src/app/core/models/diagnostic-event.model.ts
  - frontend/src/app/core/models/event-filters.model.ts
  - frontend/src/app/core/models/paginated-response.model.ts
  - frontend/src/app/core/models/aggregation.model.ts
  - frontend/src/app/core/models/index.ts
  - frontend/src/app/core/services/diagnostics-api.service.ts
autonomous: true
requirements:
  - STATE-01
must_haves:
  truths:
    - "TypeScript interfaces match the backend API response shapes exactly"
    - "API service methods build query params dynamically, skipping undefined values"
    - "API service returns typed Observables for all 4 endpoints"
    - "HttpClient is configured and can make requests through the proxy"
  artifacts:
    - path: "frontend/src/app/core/models/diagnostic-event.model.ts"
      provides: "DiagnosticEvent interface and DiagnosticLevel type"
      contains: "DiagnosticLevel"
    - path: "frontend/src/app/core/models/event-filters.model.ts"
      provides: "EventFilters interface with optional filter fields"
      contains: "EventFilters"
    - path: "frontend/src/app/core/models/paginated-response.model.ts"
      provides: "Generic PaginatedResponse<T> interface"
      contains: "PaginatedResponse"
    - path: "frontend/src/app/core/models/aggregation.model.ts"
      provides: "ErrorsPerVehicle, TopCode, CriticalVehicle interfaces"
      contains: "ErrorsPerVehicle"
    - path: "frontend/src/app/core/services/diagnostics-api.service.ts"
      provides: "DiagnosticsApiService with getEvents, getErrorsPerVehicle, getTopCodes, getCriticalVehicles"
      exports: ["DiagnosticsApiService"]
  key_links:
    - from: "frontend/src/app/core/services/diagnostics-api.service.ts"
      to: "/api/events"
      via: "HttpClient.get with query params"
      pattern: "HttpClient.*api/events"
    - from: "frontend/src/app/core/services/diagnostics-api.service.ts"
      to: "frontend/src/app/core/models/index.ts"
      via: "import for type safety"
      pattern: "import.*models"
---

<objective>
Create TypeScript interfaces mirroring the backend API response shapes and an HttpClient-based API service.

Purpose: Provides the typed contract between frontend and backend. The DiagnosticsStore (plan 03-03) depends on these models and service methods to manage state.
Output: Model interfaces and injectable API service with methods for all 4 endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/src/types/index.ts
@.planning/phases/03-frontend-foundation/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared TypeScript model interfaces</name>
  <files>
    frontend/src/app/core/models/diagnostic-event.model.ts
    frontend/src/app/core/models/event-filters.model.ts
    frontend/src/app/core/models/paginated-response.model.ts
    frontend/src/app/core/models/aggregation.model.ts
    frontend/src/app/core/models/index.ts
  </files>
  <action>
    Create model interfaces that mirror the backend types in `backend/src/types/index.ts`. These are frontend-only interfaces (no shared code between backend/frontend — monorepo but separate packages).

    1. `diagnostic-event.model.ts`:
    ```typescript
    export type DiagnosticLevel = 'ERROR' | 'WARN' | 'INFO';

    export interface DiagnosticEvent {
      id: number;
      timestamp: string;  // ISO string from JSON serialization
      vehicleId: string;
      level: DiagnosticLevel;
      code: string;
      message: string;
    }
    ```
    NOTE: `timestamp` is `string` on frontend (JSON serializes Date to ISO string), unlike backend entity which uses `Date`.

    2. `event-filters.model.ts`:
    ```typescript
    import { DiagnosticLevel } from './diagnostic-event.model';

    export interface EventFilters {
      vehicleId?: string;
      code?: string;
      level?: DiagnosticLevel;
      from?: string;  // ISO date string
      to?: string;    // ISO date string
    }
    ```

    3. `paginated-response.model.ts`:
    ```typescript
    export interface PaginatedResponse<T> {
      data: T[];
      total: number;
      page: number;
      limit: number;
    }
    ```

    4. `aggregation.model.ts`:
    ```typescript
    import { DiagnosticLevel } from './diagnostic-event.model';

    export interface ErrorsPerVehicle {
      vehicleId: string;
      errorCount: number;
      warnCount: number;
      infoCount: number;
      total: number;
    }

    export interface TopCode {
      code: string;
      count: number;
      level: DiagnosticLevel;
    }

    export interface CriticalVehicle {
      vehicleId: string;
      errorCount: number;
      latestError: string;  // ISO date string
    }
    ```

    5. `index.ts` — barrel export:
    ```typescript
    export { DiagnosticEvent, DiagnosticLevel } from './diagnostic-event.model';
    export { EventFilters } from './event-filters.model';
    export { PaginatedResponse } from './paginated-response.model';
    export { ErrorsPerVehicle, TopCode, CriticalVehicle } from './aggregation.model';
    ```
  </action>
  <verify>
    Run `cd frontend && npx ng build` — compiles without errors, no type mismatches.
  </verify>
  <done>
    All model interfaces created, matching backend API response shapes. Barrel export provides single import path `@app/core/models` (or relative path).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DiagnosticsApiService with HttpClient methods</name>
  <files>
    frontend/src/app/core/services/diagnostics-api.service.ts
  </files>
  <action>
    Create an injectable Angular service that wraps HttpClient for all backend API calls.

    `frontend/src/app/core/services/diagnostics-api.service.ts`:
    ```typescript
    import { Injectable, inject } from '@angular/core';
    import { HttpClient, HttpParams } from '@angular/common/http';
    import { Observable } from 'rxjs';
    import {
      DiagnosticEvent,
      EventFilters,
      PaginatedResponse,
      ErrorsPerVehicle,
      TopCode,
      CriticalVehicle
    } from '../models';

    @Injectable({ providedIn: 'root' })
    export class DiagnosticsApiService {
      private readonly http = inject(HttpClient);
      private readonly baseUrl = '/api';

      getEvents(filters: EventFilters, page = 1, limit = 20): Observable<PaginatedResponse<DiagnosticEvent>> {
        let params = new HttpParams()
          .set('page', page.toString())
          .set('limit', limit.toString());

        // Only add filter params that have defined, non-empty values
        if (filters.vehicleId) params = params.set('vehicleId', filters.vehicleId);
        if (filters.code) params = params.set('code', filters.code);
        if (filters.level) params = params.set('level', filters.level);
        if (filters.from) params = params.set('from', filters.from);
        if (filters.to) params = params.set('to', filters.to);

        return this.http.get<PaginatedResponse<DiagnosticEvent>>(`${this.baseUrl}/events`, { params });
      }

      getErrorsPerVehicle(from?: string, to?: string): Observable<ErrorsPerVehicle[]> {
        let params = new HttpParams();
        if (from) params = params.set('from', from);
        if (to) params = params.set('to', to);

        return this.http.get<ErrorsPerVehicle[]>(`${this.baseUrl}/aggregations/errors-per-vehicle`, { params });
      }

      getTopCodes(level?: string, from?: string, to?: string): Observable<TopCode[]> {
        let params = new HttpParams();
        if (level) params = params.set('level', level);
        if (from) params = params.set('from', from);
        if (to) params = params.set('to', to);

        return this.http.get<TopCode[]>(`${this.baseUrl}/aggregations/top-codes`, { params });
      }

      getCriticalVehicles(): Observable<CriticalVehicle[]> {
        return this.http.get<CriticalVehicle[]>(`${this.baseUrl}/aggregations/critical-vehicles`);
      }
    }
    ```

    Key implementation details:
    - Use `inject()` function (not constructor injection) — Angular 19 preferred pattern
    - Use `providedIn: 'root'` — tree-shakeable singleton
    - Build HttpParams dynamically — skip undefined/empty values to avoid sending `?vehicleId=undefined` to backend
    - Use truthy checks (`if (filters.vehicleId)`) which also skips empty strings — matching backend Zod validation that rejects empty strings
    - All methods return typed Observables — no `any` types
    - Base URL is `/api` — Angular proxy rewrites to `http://localhost:3000/api` in dev
  </action>
  <verify>
    Run `cd frontend && npx ng build` — compiles without errors, service is tree-shaken if unused but importable.
  </verify>
  <done>
    DiagnosticsApiService created with typed methods for getEvents (with filter+pagination params), getErrorsPerVehicle, getTopCodes, and getCriticalVehicles. All methods skip undefined params and return typed Observables.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx ng build` — compiles without errors
2. All model files exist under `frontend/src/app/core/models/`
3. Barrel export re-exports all models
4. Service imports from barrel export path
5. No `any` types anywhere in models or service
</verification>

<success_criteria>
- 5 model files created with interfaces matching backend response shapes exactly
- DiagnosticsApiService has 4 methods: getEvents, getErrorsPerVehicle, getTopCodes, getCriticalVehicles
- All methods return properly typed Observables
- Query params built dynamically, undefined values skipped
- Project builds without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-foundation/03-02-SUMMARY.md`
</output>
