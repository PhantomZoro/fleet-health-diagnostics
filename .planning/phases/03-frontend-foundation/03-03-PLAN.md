---
phase: 03-frontend-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - 03-02
files_modified:
  - frontend/src/app/store/diagnostics.store.ts
  - frontend/src/app/store/diagnostics-state.model.ts
autonomous: true
requirements:
  - STATE-01
  - STATE-02
  - STATE-03
  - STATE-04
  - STATE-05
must_haves:
  truths:
    - "Store manages filters, events, aggregations, loading, error as observables (STATE-01)"
    - "Filter changes are debounced at 300ms — rapid typing does not fire per keystroke (STATE-02)"
    - "New filter change cancels in-flight request via switchMap (STATE-03)"
    - "Filters and page are combined into a single API call via combineLatest (STATE-04)"
    - "All selectors use distinctUntilChanged and shareReplay(1) (STATE-05)"
    - "Error in API response does not kill the effect stream — tapResponse recovers"
  artifacts:
    - path: "frontend/src/app/store/diagnostics.store.ts"
      provides: "DiagnosticsStore ComponentStore with updaters, selectors, effects"
      exports: ["DiagnosticsStore"]
      min_lines: 80
    - path: "frontend/src/app/store/diagnostics-state.model.ts"
      provides: "DiagnosticsState interface for store shape"
      exports: ["DiagnosticsState"]
  key_links:
    - from: "frontend/src/app/store/diagnostics.store.ts"
      to: "frontend/src/app/core/services/diagnostics-api.service.ts"
      via: "inject(DiagnosticsApiService) for API calls in effects"
      pattern: "inject.*DiagnosticsApiService"
    - from: "frontend/src/app/store/diagnostics.store.ts"
      to: "frontend/src/app/core/models/index.ts"
      via: "imports for state typing"
      pattern: "import.*models"
    - from: "frontend/src/app/store/diagnostics.store.ts"
      to: "@ngrx/component-store"
      via: "extends ComponentStore"
      pattern: "extends ComponentStore"
---

<objective>
Build the NgRx ComponentStore that manages all application state with required RxJS pattern demonstrations.

Purpose: This is the core state management layer and the primary demonstration of RxJS expertise for the BMW assignment. It must showcase debounceTime, switchMap, combineLatest, tapResponse, distinctUntilChanged, shareReplay, and takeUntilDestroyed — all correctly applied.
Output: DiagnosticsStore with full reactive state management, ready for components to consume.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-frontend-foundation/03-02-SUMMARY.md
@backend/src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DiagnosticsStore with full RxJS pattern demonstration</name>
  <files>
    frontend/src/app/store/diagnostics-state.model.ts
    frontend/src/app/store/diagnostics.store.ts
  </files>
  <action>
    This is the most important file in the frontend — it demonstrates senior RxJS competency.

    1. Create `frontend/src/app/store/diagnostics-state.model.ts`:
    ```typescript
    import {
      DiagnosticEvent,
      EventFilters,
      ErrorsPerVehicle,
      TopCode,
      CriticalVehicle
    } from '../core/models';

    export interface AggregationState {
      errorsPerVehicle: ErrorsPerVehicle[];
      topCodes: TopCode[];
      criticalVehicles: CriticalVehicle[];
    }

    export interface DiagnosticsState {
      filters: EventFilters;
      events: DiagnosticEvent[];
      total: number;
      page: number;
      limit: number;
      aggregations: AggregationState;
      loading: boolean;
      error: string | null;
    }

    export const initialState: DiagnosticsState = {
      filters: {},
      events: [],
      total: 0,
      page: 1,
      limit: 20,
      aggregations: {
        errorsPerVehicle: [],
        topCodes: [],
        criticalVehicles: []
      },
      loading: false,
      error: null
    };
    ```

    2. Create `frontend/src/app/store/diagnostics.store.ts`:

    ```typescript
    import { Injectable, inject, DestroyRef } from '@angular/core';
    import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
    import { ComponentStore, tapResponse } from '@ngrx/component-store';
    import {
      switchMap,
      debounceTime,
      distinctUntilChanged,
      shareReplay,
      tap,
      combineLatest
    } from 'rxjs';
    import { DiagnosticsApiService } from '../core/services/diagnostics-api.service';
    import { EventFilters, DiagnosticEvent, PaginatedResponse } from '../core/models';
    import { DiagnosticsState, AggregationState, initialState } from './diagnostics-state.model';

    @Injectable()
    export class DiagnosticsStore extends ComponentStore<DiagnosticsState> {
      private readonly api = inject(DiagnosticsApiService);
      private readonly destroyRef = inject(DestroyRef);

      constructor() {
        super(initialState);
        // Wire up reactive effects after construction
        this.loadEventsEffect();
        this.loadAggregationsEffect();
      }

      // ─── UPDATERS ───────────────────────────────────────────

      readonly setFilters = this.updater<EventFilters>((state, filters) => ({
        ...state,
        filters,
        page: 1  // Reset page when filters change
      }));

      readonly setPage = this.updater<number>((state, page) => ({
        ...state,
        page
      }));

      readonly resetFilters = this.updater<void>((state) => ({
        ...state,
        filters: {},
        page: 1
      }));

      // ─── SELECTORS ─────────────────────────────────────────
      // STATE-05: All selectors use distinctUntilChanged + shareReplay(1)

      readonly filters$ = this.select(state => state.filters).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly events$ = this.select(state => state.events).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly total$ = this.select(state => state.total).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly page$ = this.select(state => state.page).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly loading$ = this.select(state => state.loading).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly error$ = this.select(state => state.error).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      readonly aggregations$ = this.select(state => state.aggregations).pipe(
        distinctUntilChanged(),
        shareReplay(1)
      );

      // ─── EFFECTS ────────────────────────────────────────────

      /**
       * loadEventsEffect:
       * STATE-04: combineLatest merges filters + page into single trigger
       * STATE-02: debounceTime(300) prevents firing per keystroke
       * STATE-03: switchMap cancels in-flight request on new filter/page change
       * tapResponse handles success/error WITHOUT killing the outer stream
       */
      private loadEventsEffect(): void {
        combineLatest([
          this.select(state => state.filters),
          this.select(state => state.page),
          this.select(state => state.limit)
        ]).pipe(
          debounceTime(300),
          tap(() => this.patchState({ loading: true, error: null })),
          switchMap(([filters, page, limit]) =>
            this.api.getEvents(filters, page, limit).pipe(
              tapResponse(
                (response: PaginatedResponse<DiagnosticEvent>) => {
                  this.patchState({
                    events: response.data,
                    total: response.total,
                    loading: false
                  });
                },
                (error: unknown) => {
                  const message = error instanceof Error ? error.message : 'Failed to load events';
                  this.patchState({
                    loading: false,
                    error: message
                  });
                }
              )
            )
          ),
          takeUntilDestroyed(this.destroyRef)
        ).subscribe();
      }

      /**
       * loadAggregationsEffect:
       * Triggered by filter changes (time range affects aggregations).
       * Uses same debounce + switchMap pattern for consistency.
       */
      private loadAggregationsEffect(): void {
        this.select(state => state.filters).pipe(
          debounceTime(300),
          switchMap((filters) => {
            const { from, to } = filters;
            // Fire all three aggregation requests, combine results
            return combineLatest([
              this.api.getErrorsPerVehicle(from, to),
              this.api.getTopCodes(undefined, from, to),
              this.api.getCriticalVehicles()
            ]).pipe(
              tapResponse(
                ([errorsPerVehicle, topCodes, criticalVehicles]) => {
                  this.patchState({
                    aggregations: { errorsPerVehicle, topCodes, criticalVehicles }
                  });
                },
                (error: unknown) => {
                  const message = error instanceof Error ? error.message : 'Failed to load aggregations';
                  this.patchState({ error: message });
                }
              )
            );
          }),
          takeUntilDestroyed(this.destroyRef)
        ).subscribe();
      }
    }
    ```

    CRITICAL implementation details:

    **RxJS pattern requirements (from CLAUDE.md and ROADMAP):**
    - `tapResponse` INSIDE the inner `switchMap` pipe — NEVER use `catchError` on the outer stream. `catchError` on the outer stream completes it permanently, killing the effect. `tapResponse` from `@ngrx/component-store` handles this correctly by catching errors inside the inner observable.
    - `switchMap` — cancels previous in-flight HTTP request when a new filter/page emission arrives. This is the correct operator for search/filter scenarios (not mergeMap which would allow concurrent requests, or exhaustMap which would ignore new emissions).
    - `debounceTime(300)` — placed BEFORE `switchMap` so rapid filter changes are batched into one API call. The 300ms delay prevents hammering the API on every keystroke.
    - `combineLatest` — merges filters + page + limit into a single stream. When any dimension changes, a new combined emission fires (after debounce).
    - `distinctUntilChanged` on selectors — prevents re-emissions when state updates don't change the selected slice. Default equality check works for primitives; object selectors use reference equality (fine since we spread new objects).
    - `shareReplay(1)` on selectors — late subscribers get the last emitted value immediately (important for components that subscribe after initial load).
    - `takeUntilDestroyed(destroyRef)` — automatic unsubscription when the store is destroyed. Replaces manual `ngOnDestroy` + `Subject` pattern.

    **Store is `@Injectable()` without `providedIn`** — it will be provided at the component level (feature components provide it), NOT at root. This is the ComponentStore pattern — each feature gets its own store instance.

    **setFilters resets page to 1** — when filters change, user should see page 1 of new results, not a potentially out-of-range page.
  </action>
  <verify>
    Run from `frontend/`:
    - `npx ng build` — compiles without errors
    - Verify the store file contains: `debounceTime(300)`, `switchMap`, `combineLatest`, `tapResponse`, `distinctUntilChanged`, `shareReplay(1)`, `takeUntilDestroyed`
    - Verify NO `catchError` appears on outer streams
    - Verify `@Injectable()` has no `providedIn: 'root'`
  </verify>
  <done>
    DiagnosticsStore extends ComponentStore with:
    - State: filters, events, total, page, limit, aggregations, loading, error
    - Updaters: setFilters (resets page), setPage, resetFilters
    - Selectors: all with distinctUntilChanged + shareReplay(1)
    - Effects: loadEvents (combineLatest + debounce + switchMap + tapResponse), loadAggregations (same pattern)
    - All 5 STATE requirements demonstrated: STATE-01 (observables), STATE-02 (debounce), STATE-03 (switchMap cancel), STATE-04 (combineLatest), STATE-05 (shareReplay + distinctUntilChanged)
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && npx ng build` — compiles without TypeScript errors
2. Grep for required RxJS patterns in store file:
   - `debounceTime(300)` present
   - `switchMap` present (inside effect, not at top level)
   - `combineLatest` present (combining filters + page)
   - `tapResponse` present (inside switchMap inner pipe)
   - `distinctUntilChanged()` present on all selectors
   - `shareReplay(1)` present on all selectors
   - `takeUntilDestroyed` present for cleanup
3. Grep for anti-patterns that MUST NOT exist:
   - NO `catchError` on outer effect streams
   - NO `mergeMap` (would allow concurrent requests)
   - NO `any` types
   - NO `providedIn: 'root'` on the store
</verification>

<success_criteria>
- DiagnosticsStore compiles and exports correctly
- All 5 STATE requirements demonstrably satisfied in the code
- RxJS operators used correctly per CLAUDE.md conventions
- No anti-patterns (outer catchError, mergeMap, any types)
- Store state shape matches the defined interface
- Effects wire up automatically in constructor
</success_criteria>

<output>
After completion, create `.planning/phases/03-frontend-foundation/03-03-SUMMARY.md`
</output>
