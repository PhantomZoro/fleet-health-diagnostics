---
phase: 02-backend-api-layer
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - backend/src/services/aggregation.service.ts
  - backend/src/routes/aggregations.router.ts
  - backend/src/routes/events.router.ts
  - backend/src/config/swagger.ts
  - backend/src/index.ts
  - backend/package.json
autonomous: true
requirements: [API-02, API-03, API-04, API-06]

must_haves:
  truths:
    - "GET /api/aggregations/errors-per-vehicle returns per-vehicle error counts grouped by level"
    - "GET /api/aggregations/top-codes returns top 10 error codes ordered by frequency"
    - "GET /api/aggregations/critical-vehicles returns vehicles with 3+ ERRORs in last 24h (relative to latest event)"
    - "Aggregation endpoints accept optional time range filters"
    - "Swagger UI loads at /api-docs and documents all endpoints with query params and response schemas"
    - "All aggregation data is consistent with the seeded database"
  artifacts:
    - path: "backend/src/services/aggregation.service.ts"
      provides: "Three aggregation queries against DiagnosticEvent"
      exports: ["AggregationService"]
    - path: "backend/src/routes/aggregations.router.ts"
      provides: "Three aggregation route handlers"
      exports: ["aggregationsRouter"]
    - path: "backend/src/config/swagger.ts"
      provides: "Swagger/OpenAPI configuration"
      exports: ["swaggerSpec"]
  key_links:
    - from: "backend/src/routes/aggregations.router.ts"
      to: "backend/src/services/aggregation.service.ts"
      via: "imports AggregationService, calls aggregation methods"
      pattern: "AggregationService"
    - from: "backend/src/routes/aggregations.router.ts"
      to: "backend/src/middleware/validate.ts"
      via: "uses validateQuery middleware with aggregation Zod schemas"
      pattern: "validateQuery"
    - from: "backend/src/index.ts"
      to: "backend/src/routes/aggregations.router.ts"
      via: "app.use mounts aggregationsRouter"
      pattern: "aggregationsRouter"
    - from: "backend/src/index.ts"
      to: "backend/src/config/swagger.ts"
      via: "mounts swagger-ui-express at /api-docs"
      pattern: "swagger"
---

<objective>
Build three aggregation endpoints and set up Swagger API documentation covering all routes.

Purpose: Provide aggregated fleet health analytics (errors per vehicle, top error codes, critical vehicles) for the frontend dashboard, and auto-generate interactive API documentation for the BMW reviewer.

Output: Three working aggregation endpoints with validation, plus Swagger UI at /api-docs documenting all API routes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-api-layer/02-01-SUMMARY.md
@backend/src/index.ts
@backend/src/entities/diagnostic-event.entity.ts
@backend/src/types/index.ts
@backend/src/services/event.service.ts
@backend/src/middleware/validate.ts
@backend/src/middleware/error-handler.ts
@backend/src/routes/events.router.ts
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create aggregation service with three query methods</name>
  <files>
    backend/src/services/aggregation.service.ts
    backend/src/types/index.ts
  </files>
  <action>
    **Add aggregation response types to backend/src/types/index.ts:**
    Append these interfaces (keep all existing types):
    - `ErrorsPerVehicle` — `{ vehicleId: string, errorCount: number, warnCount: number, infoCount: number, total: number }`
    - `TopCode` — `{ code: string, count: number, level: DiagnosticLevel }`
    - `CriticalVehicle` — `{ vehicleId: string, errorCount: number, latestError: string }`
    - `AggregationTimeRange` — `{ from?: string, to?: string }`

    **Create backend/src/services/aggregation.service.ts:**
    Export class `AggregationService` with three static methods:

    **1. `errorsPerVehicle(params: AggregationTimeRange): Promise<ErrorsPerVehicle[]>`**
    - Use TypeORM QueryBuilder on DiagnosticEvent.
    - GROUP BY vehicleId.
    - Use conditional COUNT for each level:
      - `SUM(CASE WHEN level = 'ERROR' THEN 1 ELSE 0 END) as errorCount`
      - `SUM(CASE WHEN level = 'WARN' THEN 1 ELSE 0 END) as warnCount`
      - `SUM(CASE WHEN level = 'INFO' THEN 1 ELSE 0 END) as infoCount`
      - `COUNT(*) as total`
    - If `from` defined, add WHERE `timestamp >= :from`.
    - If `to` defined, add WHERE `timestamp <= :to`.
    - ORDER BY `total DESC`.
    - Use `.getRawMany()` and map results to ErrorsPerVehicle type (raw results have string keys — cast numbers appropriately with `Number()`).

    **2. `topCodes(params: { level?: DiagnosticLevel } & AggregationTimeRange): Promise<TopCode[]>`**
    - GROUP BY code.
    - SELECT `code`, `COUNT(*) as count`, `level`.
    - If `level` defined, filter WHERE `level = :level`.
    - If `from`/`to` defined, add time range WHERE clauses.
    - ORDER BY `count DESC`.
    - LIMIT 10.
    - Note: GROUP BY code AND level since different levels may share codes. If level filter is applied, grouping by level is redundant but harmless.
    - Use `.getRawMany()` and map results.

    **3. `criticalVehicles(): Promise<CriticalVehicle[]>`**
    - "Critical" = vehicles with 3+ ERROR events in the last 24 hours **relative to the latest event timestamp in the database** (NOT system time — seed data has fixed timestamps).
    - First query: get the max timestamp from the database: `SELECT MAX(timestamp) as latest FROM diagnostic_events`.
    - Calculate 24h-ago: subtract 24 hours from the latest timestamp.
    - Second query (or subquery): filter events WHERE level = 'ERROR' AND timestamp >= 24h-ago, GROUP BY vehicleId, HAVING COUNT(*) >= 3.
    - SELECT `vehicleId`, `COUNT(*) as errorCount`, `MAX(timestamp) as latestError`.
    - ORDER BY `errorCount DESC`.
    - Return array of CriticalVehicle.
    - IMPORTANT: Use the DB's latest event time, NOT `new Date()`, because the seed data has timestamps from a fixed period.
  </action>
  <verify>
    Run `cd backend && npx tsc --noEmit` — zero TypeScript errors. All three methods exist on AggregationService.
  </verify>
  <done>
    AggregationService exports three static methods: errorsPerVehicle(), topCodes(), criticalVehicles(). All use QueryBuilder with proper undefined guards. criticalVehicles() uses DB-relative time window. Types added to types/index.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create aggregation routes, Swagger config, and wire everything</name>
  <files>
    backend/src/routes/aggregations.router.ts
    backend/src/routes/events.router.ts
    backend/src/config/swagger.ts
    backend/src/index.ts
    backend/package.json
  </files>
  <action>
    **Install Swagger packages:**
    Run `cd backend && npm install swagger-jsdoc swagger-ui-express` and `npm install -D @types/swagger-jsdoc @types/swagger-ui-express`.
    Use `swagger-ui-express` v5 (required for Express 5 compatibility per STATE.md blocker).

    **Create backend/src/routes/aggregations.router.ts:**
    - Import Router from express, AggregationService from service, validateQuery from middleware.
    - Export `aggregationsRouter = Router()`.
    - Define Zod schemas for aggregation query params:
      - `timeRangeSchema` — optional `from` (ISO datetime string), optional `to` (ISO datetime string)
      - `topCodesSchema` — extends timeRange + optional `level` (z.enum(['ERROR', 'WARN', 'INFO']))
    - Three routes:

      **GET /api/aggregations/errors-per-vehicle:**
      - Middleware: `validateQuery(timeRangeSchema)`
      - Handler: call `AggregationService.errorsPerVehicle({ from, to })`, respond with array.
      - Add `@openapi` JSDoc annotation.

      **GET /api/aggregations/top-codes:**
      - Middleware: `validateQuery(topCodesSchema)`
      - Handler: call `AggregationService.topCodes({ level, from, to })`, respond with array.
      - Add `@openapi` JSDoc annotation.

      **GET /api/aggregations/critical-vehicles:**
      - No validation needed (no query params).
      - Handler: call `AggregationService.criticalVehicles()`, respond with array.
      - Add `@openapi` JSDoc annotation.

    **Add @openapi JSDoc to events.router.ts:**
    If not already present from plan 02-01, ensure the GET /api/events handler has a complete `@openapi` JSDoc annotation documenting all query params and response schemas.

    **Create backend/src/config/swagger.ts:**
    - Import `swaggerJsdoc` from 'swagger-jsdoc'.
    - Configure with:
      - `definition.openapi`: '3.0.0'
      - `definition.info.title`: 'Fleet Health Diagnostics API'
      - `definition.info.version`: '1.0.0'
      - `definition.info.description`: 'REST API for fleet diagnostic event querying and aggregation'
      - `definition.servers`: [{ url: 'http://localhost:3000' }]
      - `apis`: ['./src/routes/*.ts'] (glob pattern to pick up @openapi JSDoc from all route files)
    - Export `swaggerSpec` (the generated spec object).
    - Note: swagger-jsdoc reads JSDoc `@openapi` annotations at startup and builds the OpenAPI spec.

    **Update backend/src/index.ts:**
    - Import `aggregationsRouter`.
    - Import `swaggerUi` from 'swagger-ui-express' and `swaggerSpec` from config.
    - Mount `app.use(aggregationsRouter)` after eventsRouter.
    - Mount `app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec))` before the notFoundHandler.
    - Keep all existing middleware and route ordering intact.

    **Test all endpoints:**
    Start server with `cd backend && npm run dev &`, wait 3 seconds, then curl:
    - `curl http://localhost:3000/api/aggregations/errors-per-vehicle` — should return array of vehicle error counts
    - `curl http://localhost:3000/api/aggregations/top-codes` — should return top 10 codes
    - `curl "http://localhost:3000/api/aggregations/top-codes?level=ERROR"` — should return only ERROR codes
    - `curl http://localhost:3000/api/aggregations/critical-vehicles` — should return vehicles with 3+ ERRORs in 24h window
    - `curl http://localhost:3000/api-docs` — should return Swagger UI HTML (or redirect)
    - Verify critical-vehicles returns at least VH-1001 through VH-1004 (each has 5+ ERRORs per seed data design).
    - Kill the dev server after testing.
  </action>
  <verify>
    1. `npx tsc --noEmit` — zero errors
    2. `curl http://localhost:3000/api/aggregations/errors-per-vehicle` returns 20 vehicles with counts
    3. `curl http://localhost:3000/api/aggregations/top-codes` returns up to 10 codes ordered by count DESC
    4. `curl http://localhost:3000/api/aggregations/critical-vehicles` returns 4+ vehicles (VH-1001 to VH-1004 from seed)
    5. `curl -s http://localhost:3000/api-docs/ | head -5` contains HTML (Swagger UI page)
    6. All endpoints return valid JSON
  </verify>
  <done>
    Three aggregation endpoints work with correct data. Swagger UI loads at /api-docs documenting all 4 API routes (events + 3 aggregations) with query params and response schemas. All validation works. TypeScript compiles clean.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles with zero errors (`cd backend && npx tsc --noEmit`)
2. GET /api/aggregations/errors-per-vehicle returns all 20 vehicles with errorCount, warnCount, infoCount breakdown
3. GET /api/aggregations/errors-per-vehicle?from=...&to=... filters by time range
4. GET /api/aggregations/top-codes returns top 10 codes ordered by frequency
5. GET /api/aggregations/top-codes?level=ERROR returns only ERROR-level codes
6. GET /api/aggregations/critical-vehicles returns vehicles with 3+ ERRORs in 24h window (expect 4+ from seed data)
7. Critical vehicles result is relative to latest event timestamp, NOT current system time
8. Swagger UI loads at http://localhost:3000/api-docs with interactive documentation
9. Swagger documents all routes: /api/events, /api/aggregations/errors-per-vehicle, /api/aggregations/top-codes, /api/aggregations/critical-vehicles
10. All endpoints from plan 02-01 still work correctly (events, validation, error handling)
</verification>

<success_criteria>
- Three aggregation endpoints return correct, consistent data
- Critical vehicles uses DB-relative 24h window (not system time)
- Swagger UI at /api-docs documents all API endpoints
- All @openapi JSDoc annotations present on route handlers
- Validation on aggregation query params works (time range, level enum)
- TypeScript strict mode — no `any` types
- No regressions on events endpoint or error handling
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-api-layer/02-02-SUMMARY.md`
</output>
