---
phase: 05-integration-delivery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/REQUIREMENTS.md
  - docs/ARCHITECTURE.md
  - README.md
autonomous: true
requirements:
  - DOC-01
  - DOC-02
  - DOC-03
must_haves:
  truths:
    - "REQUIREMENTS.md reads as a business-facing spec with explicit assumptions"
    - "ARCHITECTURE.md explains backend layers, frontend components, and RxJS operator rationale"
    - "README.md enables a reviewer to run the app from scratch with no prior context"
    - "All three documents are senior-engineer quality, concise, and accurate to the codebase"
  artifacts:
    - path: "docs/REQUIREMENTS.md"
      provides: "Business requirements with assumptions and out-of-scope"
      contains: "## Assumptions"
    - path: "docs/ARCHITECTURE.md"
      provides: "Backend and frontend architecture with RxJS rationale"
      contains: "## RxJS"
    - path: "README.md"
      provides: "Setup instructions for manual dev and Docker"
      contains: "docker-compose"
  key_links:
    - from: "README.md"
      to: "docker-compose.yml"
      via: "references docker-compose up command"
      pattern: "docker-compose up"
    - from: "docs/ARCHITECTURE.md"
      to: "backend/src/"
      via: "describes layered architecture matching actual code"
      pattern: "routes.*services.*entities"
---

<objective>
Create three deliverable documents: REQUIREMENTS.md (business spec with assumptions), ARCHITECTURE.md (technical concept with RxJS rationale), and README.md (setup instructions).

Purpose: BMW reviewer needs well-structured documentation that demonstrates senior-level thinking — clear requirements derivation, architecture rationale, and zero-friction setup instructions.

Output: docs/REQUIREMENTS.md, docs/ARCHITECTURE.md, README.md
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REQUIREMENTS.md and ARCHITECTURE.md</name>
  <files>docs/REQUIREMENTS.md, docs/ARCHITECTURE.md</files>
  <action>
**Create `docs/REQUIREMENTS.md`** with these sections:

1. **Project Overview** — 2-3 sentences: Fleet diagnostics console for BMW operations engineers, real-time monitoring of vehicle health events, search and filtering capabilities.

2. **Business Requirements** (5-8 items derived from the assignment scenario):
   - BR-01: Ingest and store structured diagnostic log data from fleet vehicles
   - BR-02: Provide searchable event history with combinable filters (vehicle, severity, error code, time range)
   - BR-03: Support pagination for large event datasets
   - BR-04: Aggregate error counts per vehicle for fleet-wide visibility
   - BR-05: Identify top recurring error codes across the fleet
   - BR-06: Flag critical vehicles (3+ ERROR-level events in trailing 24-hour window)
   - BR-07: Provide visual severity distinction (ERROR/WARN/INFO) for rapid triage
   - BR-08: Enable one-command deployment for evaluation

3. **Assumptions** — each with brief rationale:
   - Log format is structured text: `[timestamp] [vehicleId] [level] [code] message`
   - "Critical vehicle" defined as 3+ ERROR events within most recent 24h relative to latest event in DB (not wall clock)
   - Default pagination: page 1, 20 items per page
   - Seed data: ~500 events across 20 vehicles using realistic OBD-II codes
   - SQLite sufficient for single-instance deployment (no concurrent write scaling needed)
   - No authentication — internal operations tool on trusted network

4. **Out of Scope** (with reasoning):
   - Real-time streaming / WebSocket push — read-only dashboard, periodic refresh sufficient
   - User authentication / RBAC — internal tool assumption
   - Multi-instance / horizontal scaling — SQLite is single-writer
   - Log file upload UI — seed data approach demonstrates parsing capability
   - Alert/notification system — monitoring focus, not alerting
   - Export to CSV/PDF — read-only console pattern

**Create `docs/ARCHITECTURE.md`** with these sections:

1. **System Overview** — brief description of the monorepo: Express backend + Angular frontend + SQLite database.

2. **Backend Architecture**:
   - **Layered architecture** text diagram: `Routes → Services → TypeORM Entities → SQLite`
   - Explain each layer's responsibility:
     - Routes: HTTP handling, Zod validation middleware, response formatting
     - Services: Business logic, query building, aggregation queries
     - Entities: TypeORM decorated models with column indexes
   - **Data Model**: DiagnosticEvent entity with fields (id UUID, timestamp, vehicleId, level, code, message), indexes on timestamp, vehicleId, level, code
   - **API Design**: RESTful endpoints table listing method, path, description, query params
     - GET /api/events (filters + pagination)
     - GET /api/aggregations/errors-per-vehicle
     - GET /api/aggregations/top-codes
     - GET /api/aggregations/critical-vehicles
     - GET /health
   - **Validation**: Zod schemas in middleware, parsed params stored in res.locals.validated

3. **Frontend Architecture**:
   - **Component Tree** text diagram showing AppComponent → sidebar nav + router-outlet → DashboardComponent / EventsComponent → shared components (FilterPanel, SeverityBadge, Pagination, LoadingSpinner, Toast)
   - **Smart/Dumb Component Split**: Smart (DashboardComponent, EventsComponent) inject DiagnosticsStore. Dumb (FilterPanel, SeverityBadge, Pagination, LoadingSpinner) use only @Input/@Output.
   - **NgRx ComponentStore Data Flow**: Diagram showing Component → Store.effect → ApiService → HTTP → Backend, with Store.updater → State → Store.selector → Component (via async pipe)
   - **RxJS Operator Rationale** — explicit table:
     | Operator | Where Used | Why This Over Alternatives |
     |----------|-----------|---------------------------|
     | `switchMap` | loadEvents effect | Cancels in-flight request when new filter arrives. `mergeMap` would allow stale responses to overwrite newer ones. `concatMap` would queue — user sees outdated data while waiting. |
     | `debounceTime(300)` | Filter → API pipeline | Prevents API call per keystroke. 300ms balances responsiveness with server load. |
     | `combineLatest` | Filters + page merge | Both filter changes AND page changes should trigger re-fetch. `withLatestFrom` would only trigger on one source. |
     | `distinctUntilChanged` | All selectors | Prevents re-render when state update doesn't change a specific slice. Reference equality check. |
     | `shareReplay(1)` | All selectors | Late subscribers (async pipe after *ngIf) receive last emitted value. Without it, template bindings miss emissions. |
     | `catchError` + `EMPTY` | Inside inner switchMap | Catches HTTP errors without killing the outer effect stream. Outer catchError would permanently unsubscribe the effect. tapResponse removed in @ngrx/component-store v19. |
     | `takeUntilDestroyed` | Component subscriptions | Automatic unsubscribe on component destroy. Replaces manual ngOnDestroy + Subject pattern. |

4. **Key Trade-offs** — decision table:
   | Decision | Chosen | Alternative | Rationale |
   |----------|--------|------------|-----------|
   | Backend framework | Express 5 | NestJS | Lighter weight, shows raw architecture understanding without framework magic |
   | State management | ComponentStore | Full NgRx Store | Right-sized for single-feature app, less boilerplate (no actions/reducers/effects files) |
   | Database | SQLite + TypeORM | PostgreSQL | Zero-config, single-file, perfect for containerized demo. TypeORM provides production-like ORM patterns. |
   | Module resolution | NodeNext (ESM) | CommonJS | Modern Node.js standard, .js extensions on imports, future-proof |
   | CSS approach | Custom properties | SCSS variables | Browser-inspectable, runtime-changeable, no build step for token changes |

5. **Docker Architecture** — brief description: Multi-stage builds for both services, nginx reverse proxy, docker-compose orchestration. Reference docker-compose.yml.
  </action>
  <verify>
- docs/REQUIREMENTS.md exists with Business Requirements, Assumptions, Out of Scope sections
- docs/ARCHITECTURE.md exists with Backend Architecture, Frontend Architecture, RxJS Operator Rationale, Key Trade-offs sections
- No placeholder text — all content is specific to the actual codebase
- RxJS rationale table has at least 5 operators with "why this over alternatives" column
  </verify>
  <done>REQUIREMENTS.md contains 8 business requirements, 6 assumptions with rationale, and scoped-out items with reasoning. ARCHITECTURE.md contains layered backend diagram, component tree, RxJS operator rationale table with switchMap/debounceTime/combineLatest/catchError explanations, and key trade-off decisions.</done>
</task>

<task type="auto">
  <name>Task 2: Create project README.md</name>
  <files>README.md</files>
  <action>
Create `README.md` at project root with these sections:

1. **Title + Overview**: "Fleet Health & Diagnostics Console" — 1 paragraph describing what the app does (operations engineers monitor fleet vehicle diagnostics, search events, view aggregations, identify critical vehicles).

2. **Tech Stack** — bullet list:
   - Backend: Express 5, TypeScript (strict), TypeORM, SQLite, Zod validation
   - Frontend: Angular 19, NgRx ComponentStore, RxJS, SCSS
   - Containerization: Docker, docker-compose, nginx

3. **Prerequisites**:
   - **Docker route (recommended):** Docker + docker-compose installed
   - **Manual route:** Node.js 20+, npm 10+

4. **Quick Start — Docker** (recommended):
   ```bash
   git clone <repo-url>
   cd fleet-health-diagnostics
   docker-compose up --build
   ```
   - Frontend: http://localhost:4200
   - Backend API: http://localhost:3000/api/events
   - Swagger docs: http://localhost:4200/api-docs (proxied through nginx)

5. **Quick Start — Manual Development**:
   ```bash
   # Terminal 1 — Backend
   cd backend
   npm install
   npm run dev
   # Server at http://localhost:3000, seeds database on first run

   # Terminal 2 — Frontend
   cd frontend
   npm install
   npm start
   # App at http://localhost:4200, proxies /api to backend
   ```

6. **Project Structure** — brief tree showing backend/, frontend/, docs/ with one-line descriptions.

7. **What Works**:
   - Full-text search and filtering (vehicle ID, error code, severity level, date range)
   - Paginated event table with severity badges
   - Dashboard with summary cards and aggregation lists
   - Critical vehicle identification (3+ errors in 24h) with click-through navigation
   - Loading states, empty states, error handling with toast notifications
   - Swagger API documentation
   - One-command Docker deployment

8. **What I'd Add With More Time**:
   - Unit and integration tests (Jest for backend, Jasmine/Karma for frontend)
   - Real-time event streaming via WebSocket
   - Chart visualizations for trends over time (e.g., ngx-charts)
   - Authentication and role-based access control
   - Export to CSV functionality
   - Dark mode theme toggle using existing CSS custom property system

Keep the README concise — a reviewer should be able to scan it in under 2 minutes and have the app running in under 5.
  </action>
  <verify>
- README.md exists at project root
- Contains Docker quick start with `docker-compose up --build`
- Contains manual dev setup with both terminal commands
- Has "What Works" and "What I'd Add" sections
- No broken markdown formatting
  </verify>
  <done>README.md enables a reviewer to clone and run the app via Docker (one command) or manually (two terminals). Includes project overview, tech stack, what works, and future improvements.</done>
</task>

</tasks>

<verification>
1. docs/REQUIREMENTS.md has business requirements, assumptions, and out-of-scope sections
2. docs/ARCHITECTURE.md has backend layers, frontend components, RxJS rationale table, trade-offs table
3. README.md has Docker quick start, manual dev setup, what works, what I'd add
4. All documents reference actual file paths, endpoints, and patterns from the codebase
5. No placeholder or TODO text in any document
</verification>

<success_criteria>
- REQUIREMENTS.md reads as a business-facing spec a non-technical stakeholder could understand
- ARCHITECTURE.md demonstrates senior-level reasoning about RxJS operator choices
- README.md gets a reviewer from clone to running app in under 5 minutes
- All three documents are accurate to the actual codebase (no fictional features)
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-delivery/05-02-SUMMARY.md`
</output>
