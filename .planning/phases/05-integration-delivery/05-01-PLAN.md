---
phase: 05-integration-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/Dockerfile
  - frontend/Dockerfile
  - frontend/nginx.conf
  - docker-compose.yml
  - backend/src/config/database.ts
  - .dockerignore
autonomous: true
requirements:
  - DOC-04
must_haves:
  truths:
    - "docker-compose up builds and starts both backend and frontend containers"
    - "Frontend container serves Angular app at localhost:4200"
    - "Backend container serves API at localhost:3000"
    - "Nginx proxies /api requests from frontend container to backend container"
    - "Backend seeds database on first startup inside container"
  artifacts:
    - path: "backend/Dockerfile"
      provides: "Multi-stage Node 20 alpine build for Express API"
      contains: "FROM node:20-alpine"
    - path: "frontend/Dockerfile"
      provides: "Multi-stage Angular build with nginx serving"
      contains: "FROM nginx:alpine"
    - path: "frontend/nginx.conf"
      provides: "Nginx config with SPA fallback and API proxy"
      contains: "proxy_pass"
    - path: "docker-compose.yml"
      provides: "Orchestrates backend and frontend services"
      contains: "services"
  key_links:
    - from: "frontend/nginx.conf"
      to: "backend container"
      via: "proxy_pass to backend:3000"
      pattern: "proxy_pass.*backend"
    - from: "docker-compose.yml"
      to: "backend/Dockerfile"
      via: "build context"
      pattern: "build.*backend"
    - from: "docker-compose.yml"
      to: "frontend/Dockerfile"
      via: "build context"
      pattern: "build.*frontend"
---

<objective>
Containerize both backend and frontend services with Docker, orchestrated via docker-compose.

Purpose: Enable one-command startup (`docker-compose up`) for BMW reviewer to run the entire application from a clean clone without installing Node, npm, or Angular CLI.

Output: backend/Dockerfile, frontend/Dockerfile, frontend/nginx.conf, docker-compose.yml
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/package.json
@backend/tsconfig.json
@backend/src/index.ts
@backend/src/config/database.ts
@frontend/package.json
@frontend/angular.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend Dockerfile and update database config for Docker</name>
  <files>backend/Dockerfile, backend/src/config/database.ts, .dockerignore</files>
  <action>
Create `backend/Dockerfile` as a multi-stage build:

**Stage 1 — build:**
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY tsconfig.json ./
COPY src/ ./src/
COPY data/seed.log ./data/
RUN npx tsc
```

**Stage 2 — production:**
```dockerfile
FROM node:20-alpine AS production
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --omit=dev
COPY --from=build /app/dist/ ./dist/
COPY data/seed.log ./data/
EXPOSE 3000
CMD ["node", "dist/index.js"]
```

Key considerations:
- `better-sqlite3` is a native module — it must be installed (via npm ci) in the same alpine image that runs the app. Do NOT copy node_modules from build stage.
- Copy `data/seed.log` into production stage so the seeder can find it at runtime.
- The SQLite database file (`data/fleet.db`) is created at runtime by TypeORM, NOT copied from host.

Update `backend/src/config/database.ts` to use environment variable for synchronize:
- Change `synchronize: true` to `synchronize: process.env['NODE_ENV'] !== 'production'`
- This disables synchronize in Docker production but keeps it in dev.

Create root `.dockerignore`:
```
node_modules
dist
*.db
.planning
.claude
.git
```
  </action>
  <verify>
- `cd backend && npx tsc` compiles without errors (confirms tsconfig + source are consistent)
- Dockerfile has two FROM stages (build, production)
- database.ts uses NODE_ENV check for synchronize
- .dockerignore exists at project root
  </verify>
  <done>Backend Dockerfile builds TypeScript with tsc, runs with Node 20 alpine, copies seed.log but creates fleet.db at runtime. synchronize disabled when NODE_ENV=production.</done>
</task>

<task type="auto">
  <name>Task 2: Create frontend Dockerfile, nginx.conf, and docker-compose.yml</name>
  <files>frontend/Dockerfile, frontend/nginx.conf, docker-compose.yml</files>
  <action>
Create `frontend/Dockerfile` as a multi-stage build:

**Stage 1 — build:**
```dockerfile
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npx ng build --configuration production
```

Note: Angular 19 with the `application` builder outputs to `dist/frontend/browser/` (not `dist/frontend/` directly). Verify this path exists after build. The output path in angular.json is `dist/frontend` but the application builder adds a `browser/` subdirectory.

**Stage 2 — serve:**
```dockerfile
FROM nginx:alpine AS production
COPY --from=build /app/dist/frontend/browser/ /usr/share/nginx/html/
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 4200
```

Create `frontend/nginx.conf`:
```nginx
server {
    listen 4200;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # SPA fallback — all non-file routes serve index.html
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Proxy API requests to backend container
    location /api {
        proxy_pass http://backend:3000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # Proxy Swagger docs to backend container
    location /api-docs {
        proxy_pass http://backend:3000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
    }
}
```

Key nginx details:
- Listen on port 4200 (matches dev server port for consistency)
- `try_files` with `/index.html` fallback enables Angular routing (SPA)
- `/api` proxy to `backend:3000` — uses Docker service name as hostname
- `/api-docs` proxy also forwarded so Swagger UI works through frontend port

Create `docker-compose.yml` at project root:
```yaml
version: "3.8"

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - PORT=3000
    volumes:
      - backend-data:/app/data
    networks:
      - fleet-network

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "4200:4200"
    depends_on:
      - backend
    networks:
      - fleet-network

volumes:
  backend-data:

networks:
  fleet-network:
    driver: bridge
```

Key docker-compose details:
- `backend-data` named volume persists the SQLite database across container restarts
- `depends_on: backend` ensures backend starts before frontend (nginx needs backend hostname to resolve)
- Both services on same `fleet-network` so nginx can reach `backend:3000` by service name
- NODE_ENV=production disables TypeORM synchronize in the container
  </action>
  <verify>
- `frontend/Dockerfile` has two FROM stages
- `frontend/nginx.conf` contains `proxy_pass http://backend:3000` and `try_files`
- `docker-compose.yml` defines `backend` and `frontend` services
- docker-compose.yml has `networks`, `volumes`, `depends_on` configured
  </verify>
  <done>Frontend Dockerfile builds Angular with ng build and serves via nginx. nginx.conf proxies /api to backend container and falls back to index.html for SPA routes. docker-compose.yml orchestrates both services with shared network, named volume for DB persistence, and production environment variables.</done>
</task>

</tasks>

<verification>
1. All four Docker files exist: backend/Dockerfile, frontend/Dockerfile, frontend/nginx.conf, docker-compose.yml
2. Backend Dockerfile: multi-stage, Node 20 alpine, tsc build, npm ci --omit=dev for production
3. Frontend Dockerfile: multi-stage, ng build production, nginx:alpine serve
4. nginx.conf: SPA fallback, API proxy to backend:3000, port 4200
5. docker-compose.yml: two services, shared network, volume for DB, depends_on
6. database.ts: synchronize disabled when NODE_ENV=production
</verification>

<success_criteria>
- `docker-compose config` validates the compose file without errors
- Backend Dockerfile correctly handles native better-sqlite3 module (npm ci in production stage)
- Frontend nginx config proxies /api to backend container by service name
- Database synchronize is environment-aware (enabled dev, disabled production)
</success_criteria>

<output>
After completion, create `.planning/phases/05-integration-delivery/05-01-SUMMARY.md`
</output>
